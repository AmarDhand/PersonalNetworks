################################################################################
# PROJECT: PersonalNetworks 
# PURPOSE: Clean up ego-centric data for easier data analysis
# DIR:     "~/Desktop/PersonalNetworks"
# INPUTS:  Fake data created in REDCap ("20180806_PersonalNetwork_data.csv") 
#          Can be replaced with real data of participants.
# OUTPUTS: A ego_data.rda file that contains data on Ego.
# AUTHORS: Liam McCafferty, Abby Halm, Nuzulul Kurniansyah, Amar Dhand
# CREATED: 10/29/18
# LATEST:  05/07/19
# PSERIES: NA
# NSERIES: NA
# NOTES:   Adapted from Personal Health Survey Clean Data 1 code, designed to be
#            modular for data analysis.
#          Output variable is called "sample_data"
#          This code is still in beta, please email w/ suggestions or questions
#            lmccafferty@bwh.harvard.edu
###############################################################################

###############################################################################
############################## Code Intro #####################################
###############################################################################
#LM - This code is specifically designed for data analysis. Its output is only
#  readable by R (which preserves all work done on the data) and is purposefully
#  designed to basically process the raw data into something which should be
#  easier for a data analyst to work with. This isn't required for analysis, so
#  feel free to skip it if you feel like your own processing would better. However
#  I felt it would be useful.

#The end goal of the code is:
#1) To not make any assumptions of the data. It does not pre-make proportions or
#     stats, other than network metrics.
#2) To be modular in design. I will set an example of how I structure each
#     inputs for each variable/variable type, so if your survey has different
#     variable names or new variables then it should be relatively simple to add them
#     to the structure.

#Generally the REDCap raw outputs (for the ego) are structured in 3 ways:
#Raw input: this could be a number, or a name, or just a word that the
#  respondent entered in. We purposefully import all of the data so that strings
#  are not factors, so in total most of this stuff doesn't need any processing.
#  It may be a good idea to check them, (using the head() function is useful for
#  this) but otherwise they should be fine.
#Radial question: these questions are multiple-choice but only have one possible
#  value selected. These are not too challenging to deal with, as we only have to
#  deal with a single possible value entered. They are also self-contained in a
#  single variable. Since the values from REDCap come in number form which
#  corresponds to certain values for the question, we just turn them into a factor
#  and substitute the levels with what we want. Pretty simple.
#Checkbox question: these questions are multiple-choice but can take multiple
#  possible values. Needless to say this can be a whole can of worms for a couple
#  reasons.
#  For one, the values are split across multiple variables with a suffix
#    like "___1" distinguishing the possible values. Note that the suffix is
#    auto-generated by REDCap, so it should be pretty consistent between surveys.
#  Two, for this code to not make any assumptions about the data, it needs to
#    preserve every possible value entered into the question.
#  Therefore we follow a basic method that splits the questions into their
#    consituent parts (with the names of the selected area being renamed to the
#    values we want), and a series of piped functions to basically make a list of
#    the values. This method is a bit different from the alter_data.R code, in you
#    have to manually determine how many possible values the code can take.
# #############################################################################

#Empties Global Environment cache
rm(list = ls())

#Set working directory to current file location
#To set to own working directory
#  select "Session->Set Working Directory->To Source File Location"
#  then copy result in console into current "setwd("")".
setwd("~/Desktop/London Project")

#Detatches all packages from current iteration of R, most packages interfere with this code
detach_all_packages <- function() {
  ##########
  # Function: Detatches all attatched packages from current instance of R
  # Inputs: none, just call the function
  # Ouputs: none
  # Credit to mjaniec on stack overflow for function logic
  ##########  
  basic.packages <- c("package:stats", "package:graphics", "package:grDevices",
                      "package:utils", "package:datasets",
                      "package:methods", "package:base")
  package.list <- search()[ifelse(unlist(gregexpr("package:",
                                                  search())) == 1, TRUE, FALSE)]
  package.list <- setdiff(package.list, basic.packages)
  if (length(package.list) > 0)  for (package in package.list) detach(package,
                                                                      character.only = TRUE)
}
detach_all_packages()

#Importing packages. If not yet installed, packages can be installed by going to:
#  Tools -> Install Packages, then enter their exact names from within each
#  library()
library(tidyverse)
library(igraph) # To transform and analyze network data

#Read in data
#Imports data and assigns it to variable "sample_data"
sample_data <- read.csv("ToolForVisuallyMappi_DATA_2019-05-31_2140.csv", 
	stringsAsFactors = FALSE)

#Stores "sample_data" as a table data frame for easier reading
base_data <- sample_data <- tbl_df(sample_data)

###############################################################################
############################## Examples of modules ############################
###############################################################################

#We'll do some quick example to show what is going on here.
example_data <- sample_data %>% select(record_id, sex, race___1:race___88)

################# Radial variable ############

#we use function factor() to convert into a factor. The values entered into
#  "levels" is all possible numeric values for the variable
example_data$sex <- factor(example_data$sex, levels = c("0", "1", "2"))

#We then convert the numeric levels into the exact answers for the questions.
#  Note that this could be done within factor() with the command "labels = ", but
#  it looks a bit cleaner to seperate into two different lines.
levels(example_data$sex) <- c("Female","Male","Other")

############## Checkbox Variables ############

#First we isolate the variables we want.
r <- sample_data %>% select(record_id, race___1:race___88)

#This is an extremely important part. Because of the way we end up sorting the
#  data, the name for each column will end up being the actual value entered into
#  our final dataset. So we name our record_id (which is used to preserve order),
#  and then we name each checkbox variable with its constituent answer.
colnames(r) <- c("record_id", "Black or African American", "White",
                 "American Indian/Alaska Native", "Asian",
                 "Native Hawaiian or Other Pacific Islander", "Other",
                 "Skip question")

#I'll try to break down each step within the gather block...
#First we will be assigning all of this to a variable. Don't assign it to the
#  data directly as we can possibly lose order, and thus assign data into
#  incorrect record_id's. We'll get to actual assignment later.
#Note that we use the function %>% or the "pipe function". This is from the R
#  package "magrittr" (contained in tidyverse). This function basically allows us
#  to chain other functions together in a clean manner. It automatically inputs
#  the results of the previous function/object's result into the function which
#  follows it. For example c(1,1) %>% sum() %>% print() would take the vector
#  c(1,1), sum it, then print the product of that sum.
race1 <- r %>%
  
  #Second, we use the function gather(). Gather will group and count each variable
  #  within a dataframe into a "tall" dataset. Note that the names of each variable
  #  end up under "race", and then the "count" is the number assigned to this
  #  variable (its not literally the count of the variable, but the value assigned
  #  to it). Note that was also use "-record_id" to ensure that the record_id's are
  #  not added as a variable to be gathered, thus they are not counted but rather
  #  are duplicated for each "race", which makes them act like an identifier (and
  #  if we marked multiple variables they would do the same thing).
  gather(race, count, -record_id) %>%
  
  #Third we filter out all rows which do not have the count (value) of "1". We can
  #  do this as REDCap checkbox variables are always binaries, so 1's will be a
  #  selected answer, 0's will be an unselected answer.
  filter(count == 1) %>% 
  
  #Fourth we arrange the dataframe by the record_id. This way every record_id is
  #  next to each other and sequencial. Its not necessary, but more convenient
  #  visually.
  arrange(record_id) %>%
  
  #Fifth we remove the variable "count". As we have already removed all variables
  #  which have the value of 0, we therefore know that all present variables are the
  #  selected option by the respondent.
  select(-count) %>%
  
  #Sixth we group by record_id . Although not readily appearent by its visual
  #  output, this effectively sets the data into groups by the values of the
  #  designated key (record_id in this case). We can select individual parts of each
  #  group at will, which leads to...
  group_by(record_id) %>%
  
  #Seventh we slice out the portion of the group we desire. In this example we
  #  slice from index 1 of each group, or the first option that the respondent
  #  selected.
  #Note that changing slice to other indices is how we can access all of
  #  the data each respondent entered into the checkbox. The number of possible
  #  options the coder wants to display can be determined by the number of times
  #  they repeat this code with increasing the slice number.
  #Also note that as this code selects the first option entered by the respondent,
  #  not taking every slice will bias the results in favor of checkbox answers that
  #  are given first. I would advise repeating this function block a number of time
  #  equal to the number of possible answers within the question if the user wants
  #  to preserve all data.
  slice(1) %>% 
  
  #Finally we structure everything into a dataframe. This makes assignement into
  #  our full dataset easy. Technically the last step is assigning all of this to
  #  the variable of our choice, but that is listed first just due to the way piping
  #  works.
  data.frame()


#Here's how it all looks put together. Note I'm not atually fully repeating the
#  process, as I have slice(2) rather than slice(1), which means we are actually
#  taking the 2nd possible value for the checkbox.
race2 <- r %>% gather(race, count, -record_id) %>% filter(count == 1) %>% 
  arrange(record_id) %>% select(-count) %>% group_by(record_id) %>% slice(2) %>% 
  data.frame()

#Repeating a third time. I do not do this in the base code as we found no one
#  ever entered more than 2 races, however I'm putting this here to give an
#  example of how we would deal with >3 possible/likely options.
race3 <- r %>% gather(race, count, -record_id) %>% filter(count == 1) %>% 
  arrange(record_id) %>% select(-count) %>% group_by(record_id) %>% slice(3) %>% 
  data.frame()

#Now we use the function "left_join()" to combine the variables we stored our
#  slices. If you have more than 2 slices, then use left_join() on dataset we are
#  combining into with each additional slice.
#Note that the dataset first listed in left_join() is the "key", so order is
#  preserved in this dataset, as well as "NA's" automatically introduced if the
#  row does not exist in the dataset we attaching. This can be important as you
#  should always put the dataset you are adding stuff onto first in the function.
race <- left_join(race1, race2, by = 'record_id')
race <- left_join(race, race3, by = 'record_id')

#Now we just name the variables of our combined dataset to our desired names.
colnames(race) <- c("record_id", "race1", "race2", "race3")

#Finally we left_join the combined dataset onto our base dataset. We also remove
#  the raw variables which constructed this processed data in this example, but
#  you do not need to do this if you feel that it is unnessary.
example_data <- left_join(example_data, race, by = "record_id") %>% 
  select(-race___1:-race___88)

#Removing Examples so we may start doing actual processing
rm(example_data, r, race, race1, race2, race3)

# #############################################################################

###############################################################################
########################### Data Processing ###################################
###############################################################################


#Study ID######################################################################
#Set record_id variable to category to signify the unique values of each
#record_id. This may not be necessary.
sample_data$record_id <- factor(sample_data$record_id)


#Sex ##########################################################################
sample_data$sex <- factor(sample_data$sex, levels = c("0", "1", "2"))
#assigns levels to variable "sex"
levels(sample_data$sex) <- c("Female","Male","Other")

#Ego's race####################################################################
#Due to multiple choice, code below organizes respondent's choices
#  into race1 and race2. If the respondent only chooses 1 race, the value for 
#  "race2" will be NA
r <- sample_data %>% select(record_id, race___1:race___88)
colnames(r) <- c("record_id", "Black or African American", "White",
                 "American Indian/Alaska Native", "Asian",
                 "Native Hawaiian or Other Pacific Islander", "Other",
                 "Skip question")
#creates variable, "race1", that contains the first race a participant chooses
#  if the participant selects multiple races, then "race1" variable represents
#  the race that appears first in the list of choices, and does NOT denote any 
#  ordering assigned by the participant 
race1 <- r %>% gather(race, count, -record_id) %>% filter(count == 1) %>% 
  arrange(record_id) %>% select(-count) %>% group_by(record_id) %>% slice(1) %>% 
  data.frame()
#creates variable, "race2", that contains the second race a participant chooses
#  if the participant selects multiple races, then "race2" variable represents
#  the race that appears second in the list of choices, and does NOT denote any 
#  ordering assigned by the participant 
race2 <- r %>% gather(race, count, -record_id) %>% filter(count == 1) %>% 
  arrange(record_id) %>% select(-count) %>% group_by(record_id) %>% slice(2) %>% 
  data.frame()

#creates a table that combines "race1" and "race2" by record_id
race <- left_join(race1, race2, by = 'record_id')
colnames(race) <- c("record_id", "race1", "race2")
#adds "race" table onto "sample_data", thus adding variables "race1" and "race2"
#  to the original data frame, containing all variables
sample_data <- left_join(sample_data, race, by = "record_id") %>% 
  select(-race___1:-race___88)

#Education#####################################################################
sample_data$edu <- factor(sample_data$edu, 
	levels = c(1, 2, 3, 4, 5, 6, 88))
levels(sample_data$edu) <- c("Some high school or less", "High school grad", 
	"Some college", "Associate degree", "Bachelor's degree", "Graduate degree",
	"Prefer not to answer")

#Ego Employment################################################################

sample_data$employment <- factor(sample_data$employment, levels = c(1,2,3,4,5,6,7,0))

levels(sample_data$employment) <- c("Employed for wages", "Self-employed",
                                  "Out of work and looking for work",
                                  "Student", "Retired", "Unable to work",
                                  "Prefer not to answer",
                                  "Out of work but not currently looking for work")

#Ego Occupation################################################################
sample_data$occupation <- factor(sample_data$occupation, levels = c("1", "2", 
	"3", "4", "5", "6", "7", "8", "9", "10", "77"))
#note that for participants who do not select "employment___2" (employed) will
#  have NA's as their value.
levels(sample_data$occupation) <- c("Executive, manager", 
	"Sales or clerical worker", "Mechanic, electrician, skilled worker", 
	"Machine operator, inspector, bus/cab driver", "Service worker", 
	"Professional", "Business owner", "Laborer, unskilled worker", "Farming", 
	"Military", "Other")


#Ego Income####################################################################
sample_data$income <- factor(sample_data$income, levels = c("1", "2", "3", "4",
	"5"))
levels(sample_data$income) <- c("less than $5,000", "$5,000 to $49,000", 
	"$50,000 to $169,000", "$170,000 to $499,000", "more than $500,000")

#Married ######################################################################
sample_data$married <- factor(sample_data$married, levels = c(0,1))
levels(sample_data) <- c("Not married", "Married")

#Live Alone ###################################################################
sample_data$live_alone <- factor(sample_data$live_alone, levels = c(0,1))
levels(sample_data) <- c("No", "Yes")

#Ego Alcohol###################################################################
sample_data$alcohol <- factor(sample_data$alcohol, levels = c(1, 0, 9))
levels(sample_data$alcohol) <- c("Yes", "No", "I do not drink heavily")

#Ego Smoke ####################################################################
sample_data$smoke <- factor(sample_data$smoke, levels = c(1, 0, 9))
levels(sample_data$smoke) <- c("Yes","No","I do not smoke")

#Ego Exercise##################################################################
sample_data$exercise <- factor(sample_data$exercise, levels = c(1, 0))
levels(sample_data$exercise) <- c("Yes","No")

#Ego Diet######################################################################
sample_data$diet <- factor(sample_data$diet, levels = c(1, 0))
levels(sample_data$diet) <- c("Yes","No")

#Ego Health Problems###########################################################
#Ego Health problems organized into columns
#The code below organizes the Ego's Health Problems (in which the participant
#  can select multiple choices) into columns. 
#same code as for "race" variable
h <- sample_data %>% select(record_id, health___1:health___0)
colnames(h) <- c("record_id", "General Health", "Pain", "Cognitive/Mental Health",
                 "Cardiac", "No Problems")
#creates variable, "health_prob1", that contains the first health problem a 
#  participant chooses if the participant selects multiple health problems, 
#  then "health_prob1" variable represents the health problem that appears first
#  in the list of choices on REDCap, and does NOT denote any ordering 
#  assigned by the participant 
#The same code is then used to create variables for any second, third, or fourth
#  health problems the participant chooses.
health_prob1 <- h %>% gather(health_prob, count, -record_id) %>% 
  filter(count == 1) %>% arrange(record_id) %>% select(-count) %>% 
  group_by(record_id) %>% slice(1) %>% data.frame()
health_prob2 <- h %>% gather(health_prob, count, -record_id) %>% 
  filter(count == 1) %>% arrange(record_id) %>% select(-count) %>% 
  group_by(record_id) %>% slice(2) %>% data.frame()
health_prob3 <- h %>% gather(health_prob, count, -record_id) %>% 
  filter(count == 1) %>% arrange(record_id) %>% select(-count) %>% 
  group_by(record_id) %>% slice(3) %>% data.frame()
health_prob4 <- h %>% gather(health_prob, count, -record_id) %>% 
  filter(count == 1) %>% arrange(record_id) %>% select(-count) %>% 
  group_by(record_id) %>% slice(4) %>% data.frame()
health_problems <- left_join(health_prob1, health_prob2, by = 'record_id')
health_problems <- left_join(health_problems, health_prob3, by = 'record_id')
health_problems <- left_join(health_problems, health_prob4, by = 'record_id')
colnames(health_problems) <- c("record_id", "health_problem1", "health_problem2",
                               "health_problem3", "health_problem4")
sample_data <- left_join(sample_data, health_problems, by = "record_id") %>% 
  select(-health___1:-health___0)

# Technical Difficulties ######################################################
sample_data$difficulties <- factor(sample_data$difficulties, levels = c(1,0))
levels(sample_data$difficulties) <- c("Yes", "No")

#Network Size and Ties#########################################################

##Calculate total network size. Defined as all unique names entered in name
#generator boxes and extra boxes provided.

#apply 'calculate_size' function to all study IDs
network_size <- sample_data %>% select(name_1:name_15) %>% apply(1,sum)

#merge network_size and remove other size variables to reduce confusion
sample_data <- cbind(sample_data, network_size) %>% select(-size, -first)

#Select record_id and each relationship tie
shape <- sample_data %>% select(record_id, tie1:a_tie105) %>%
  group_by(record_id) %>% slice(1)

#Making a function that will create a blank matrix, then fill it with ties 
#from one record_id, then assign EGO and alter number to the matrix
make_matrix <- function(x) {
  ##########
  # Function: Creates an NA-stripped matrix from a single row dataset
  # Inputs: x = Variable that stores the dataset
  # Ouputs: matrix "mat", the matrix will be stripped of people which have zero ties,
  #           the matrix will also turn diagonal NA's (and mistaken NA's) into 0's
  ##########
  ties <- as.integer(shape[x, -1]) #select row for ID x
  mat <- matrix(NA, 16, 16) #create empty 16 x 16 matrix, with all values = NA
  mat[lower.tri(mat)] <- ties #fill lower triangle of matrix with ties
  mat <- t(mat) #transpose the matrix
  mat[lower.tri(mat)] <- ties #fill the lower triangle of matrix with ties, making 
  #                            the matrix redundant
  colnames(mat) <- rownames(mat) <- c("EGO", "1", "2", "3", "4", "5", "6", "7", 
                                      "8", "9", "10", "11", "12", "13", "14", "15")
  mat <- mat[(!colSums(mat, 1) == 0), (!colSums(mat, 1) == 0)] #remove NA values
  diag(mat) <- 0 #assign diagonal, which represents an individual's tie with 
  #               him or herself equal to 0
  return(mat)
}

# Build Matrix for All Participants
#Using code developed by Amar Dhand, MD DPHIL (06/16), built a 
#loop that applies the matrix function to every row. 100+ lines of code to 2!
z <- array(1:nrow(shape)) # An array of the number of rows
mats <- lapply(z, make_matrix) # Applies the matrix function to every study ID

#Transform to igraph objects with removal of ego

#First, identify the very small networks that need to be analyzed separately
#The code for calculating network metrics in the remainder of this script
#breaks for networks that contain less than 2 alters. Any networks in the dataset
#that contain less thab 2 alters (network size of less than 3, including ego) 
#should be investigated further.
rowsize <- unlist(lapply(mats, nrow))
#create subset list with small networks (less than 3 individuals, including ego)
small <- mats[rowsize < 3]

#subset of list without small networks. All network metric calculations below
#will be made using this subset of networks containing more 2 or more alters 
mats <- mats[!rowsize < 3]

#creates igraph object with REMOVAL of Ego
make_graph <- function (x) {
  ##########
  # Function: Creates an NA-stripped matrix from a single row dataset
  # Inputs: x = Variable that stores the dataset
  # Ouputs: matrix "mat", the matrix will be stripped of people which have zero ties,
  #           the matrix will also turn diagonal NA's (and mistaken NA's) into 0's
  ##########  
  graph.adjacency(x[-1, -1], mode = "undirected", weighted = TRUE)
}
graphs <- lapply(mats, make_graph) #creation of graph objects
names(graphs) <- names(mats) #carry over patient id labels

# Calculate maximum, avg degree, and density of alters after removal of Ego
max_degree <- unlist(lapply(graphs, function(x){max(degree(x))}))

mean_degree <- unlist(lapply(graphs, function(x){mean(degree(x))}))

density <- unlist(lapply(graphs, function(x){graph.density(x)}))

#*Important to note: The above is calculated WITHOUT THE EGO, whereas below is 
#  calculated WITH THE EGO.*
#Calculate constraint and effective size (Burt, 1992)
library(egonet) # careful of interference with igraph functions. Do not load 
#                 before calculating degree and density without EGO (above)

#Calculate constraint with EGO
constraint <- unlist(lapply(mats, function(x){as.numeric(index.egonet(x, 
                                                                      index = list("constraint")))}))

#Calculate effective size with EGO
effsize <- unlist(lapply(mats, function(x){as.numeric(index.egonet(x, 
                                                                   index = list("effsize")))}))

#Create data frame, called "structure," that includes maximum and average degree, 
#  density, and constraint 
#  also include constraintInt here as well which is constraint x 100.
structure <- data.frame(max_degree, mean_degree, density, constraint,
                        constraintInt = constraint * 100, effsize)

#Add record_id to "structure" data frame, so that we can add it to the original 
#  data set
record_id <- shape$record_id[!rowsize < 3] #study id without small networks
structure <- cbind(record_id = record_id, structure, stringsAsFactors = FALSE)

#Add the "structure" data frame to the original data set by matching "record_id"
sample_data <- left_join(sample_data, structure, by = c("record_id")) 


#create ego data file of data frame with all changes made in code
save(sample_data, file = "ego_data.rda")
